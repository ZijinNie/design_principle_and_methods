package ca.mcgill.ecse211.project;

import static ca.mcgill.ecse211.project.Resources.*;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import lejos.hardware.Sound;


/**
 * Controls the robot's movements based on ultrasonic data.
 * <br><br>
 * Control of the wall follower is applied periodically by the UltrasonicController thread in the 
 * while loop in {@code run()}. Assuming that {@code usSensor.fetchSample()} and {@code 
 * processUsData()} take ~20ms, and that the thread sleeps for 50 ms at the end of each loop, then
 * one cycle through the loop is approximately 70 ms. This corresponds to a sampling rate of 1/70ms
 * or about 14 Hz.
 */
public class USDriver implements Runnable {
  
  /**
   * The distance remembered by the {@code filter()} method.
   */
  private int prevDistance;
  
  /**
   * The number of invalid samples seen by {@code filter()} so far.
   */
  private int invalidSampleCount;
  
//Thread control tools
 /**
  * Fair lock for concurrent writing.
  */
 private static Lock lock = new ReentrantLock(true);
 
 /**
  * Indicates if a thread is trying to reset any position parameters.
  */
 private volatile boolean isResetting = false;

 /**
  * Lets other threads know that a reset operation is over.
  */
 private Condition doneResetting = lock.newCondition();
  
  /**
   * Buffer (array) to store US samples. Declared as an instance variable to avoid creating a new
   * array each time {@code readUsSample()} is called.
   */
  private float[] usData = new float[usSensor.sampleSize()];
  

  /**
   * Constructor for an abstract UltrasonicController. It makes the robot move forward.
   */
  private volatile boolean exit = false;
  
  private volatile float minDist;
  
  private volatile float curDist;
  
  private float firstAngle, secondAngle;
  
  public USDriver() {
    
  }
  

  /**
   * Samples the US sensor and invokes the selected controller on each cycle (non Javadoc).
   * 
   * @see java.lang.Thread#run()
   */
  public void run() {
    
    minDist = Float.MAX_VALUE;
    float cur,prev;  
    prev = readUsDistance();
    int count = 0;
    firstAngle = 0;
    secondAngle= 0;
    
    while(!exit ) {
      cur = readUsDistance();
      
      if(cur<minDist) minDist = cur;
      
      if((cur<= TURNING_THRESHOLD && prev >= TURNING_THRESHOLD) ||
          (cur>= TURNING_THRESHOLD && prev <= TURNING_THRESHOLD)) {
         
         if(count ==0) {
           firstAngle = (float)Resources.odometer.getXyt()[2];
           Sound.beep();
         }
         else {
           secondAngle = (float)Resources.odometer.getXyt()[2];
           CircleTurningDriver.stopMotors();
           stop();
           break;
         }
         count +=1;
       }
      
      try {
        Thread.sleep(50); // make the sensor sampling frequency be 20/s
      } catch (InterruptedException e) {
      }
      
    }
    
    
  }

  public float getFirstAngle() {
    return firstAngle;
  }


  public void setFirstAngle(float firstAngle) {
    this.firstAngle = firstAngle;
  }


  public float getSecondAngle() {
    return secondAngle;
  }


  public void setSecondAngle(float secondAngle) {
    this.secondAngle = secondAngle;
  }


  public float getMinDist() {
    return minDist;
  }


  public void setMinDist(float minDist) {
    this.minDist = minDist;
  }


  /**
   * Returns the filtered distance between the US sensor and an obstacle in cm.
   * 
   * @return the filtered distance between the US sensor and an obstacle in cm
   */
  public int readUsDistance() {
    usSensor.fetchSample(usData, 0);
    // extract from buffer, convert to cm, cast to int, and filter
    return filter((int) (usData[0] * 100.0));
  }
  
  /**
   * Rudimentary filter - toss out invalid samples corresponding to null signal.
   * 
   * @param distance raw distance measured by the sensor in cm
   * @return the filtered distance in cm
   */
  int filter(int distance) {
    if (distance >= 255 && invalidSampleCount < INVALID_SAMPLE_LIMIT) {
      // bad value, increment the filter value and return the distance remembered from before
      invalidSampleCount++;
      return prevDistance;
    } else {
      if (distance < 255) {
        // distance went below 255: reset filter and remember the input distance.
        invalidSampleCount = 0;
      }
      prevDistance = distance;
      return distance;
    }
  }

  
  public void stop() {
    exit = true;
  }



  public float getCurDist() {    
    float cur = 0;
    lock.lock();
    try {
      while (isResetting) { // If a reset operation is being executed, wait until it is over.
        doneResetting.await(); // Using await() is lighter on the CPU than simple busy wait.
      }
      cur = curDist;
        
    } catch (InterruptedException e) {
      e.printStackTrace();
    } finally {
      lock.unlock();
    }

      return cur;
  }


  public void setCurDist(float dist) {
    lock.lock();
    isResetting = true;
    try {
      this.curDist = dist;
      isResetting = false;
      doneResetting.signalAll();
    } finally {
      lock.unlock();
    }
  }

}
